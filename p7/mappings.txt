# test sequence

## SimpleAdd
push constant 16
@16 
D=A
@SP
A=M
M=D    //M[A] = 16
@SP    // Stack goes up
M=M+1

*********************************************add
@SP
M=M-1
A=M
D=M
@SP
M=M-1
A=M
D=D+M
@SP
A=M
M=D
@SP
M=M+1

## StackTest 
*********************************************eq x==y
@SP
M=M-1           /// Dekr SP (get y)
A=M
D=M             // Lade y ins D Register
@SP
M=M-1           // Dekr SP (get x)
A=M
D=M-D           // Lade x - y ins D Register
@EQ_1        // die 1 ist dynamisch anhand vm row index. Es gibt ja mehrere eq in einem vm file
D;JEQ           // Wenn x - y = 0; Springe zu Ist Gleich
@SP             // Kein M=M-1 oder M=M+1 nötig. SP zeigt auf die nächste zu befüllende Stelle. Muss erst am Schluss inkrementiert werden um auf nächste zu befüllende Stelle + 1 zu zeigen
A=M
M=0             // x und y waren nicht gleich. Setze Memory bei SP auf 0 / False
@END_EQ_1     // Springe zum Ende
0;JMP
(EQ_1)          // Werte waren gleich
@SP             // Selbe wie im not equal Block dieser Funktion. Kein inkr/dekr nötig   
A=M
M=-1            // Setze Memory bei SP auf -1 / True
(END_EQ_1)
@SP             // Inkrementiere den Stack Pointer damit er eins vor dem letzten validen Wert (hier true/false) zeigt
M=M+1

*********************************************lt x < y
@SP
M=M-1
A=M
D=M             // y in D
@SP
M=M-1
A=M
D=M-D          // x-y. Das kann man abstrahieren. Ist wie bei x=y und dann wahrscheinlich auch bei x>y
@LT_1
D;JLT
@SP           // auch abstrahierbar? true/false setzen mit oder ohne @SP
A=M
M=0
@END_LT_1
0;JMP
(LT_1)
@SP
A=M
M=-1
(END_LT_1)
@SP
M=M+1


*********************************************gt x > y
@SP
M=M-1
A=M
D=M
@SP
M=M-1
A=M
D=M-D
@GT_1
D;JGT
@SP
A=M
M=0
@END_GT_1
0;JMP
(GT_1)
@SP
A=M
M=-1
(END_GT_1)
@SP
M=M+1

*********************************************sub x - y
@SP
M=M-1
A=M
D=M
@SP
M=M-1
A=M
D=M-D
@SP
A=M
M=D
@SP
M=M+1

*********************************************neg -y
@SP
M=M-1
A=M
M=-M
@SP
M=M+1

*********************************************and x And y
@SP
M=M-1
A=M
D=M
@SP
M=M-1
A=M
D=D&M
@SP
A=M
M=D
@SP
M=M+1

*********************************************or x Or y
@SP
M=M-1
A=M
D=M
@SP
M=M-1
A=M
D=D|M
@SP
A=M
M=D
@SP
M=M+1


*********************************************not Not x
@SP
M=M-1
A=M
M=!M
@SP
M=M+1

## BasicTest

## PointerTest

##StaticTest
___________________________________________________
# segments

## Stack Pointer
@SP

## constant

## local
@LCL

## argument
@ARG

## this
@THIS

## that
@THAT

## pointer
push pointer 0 -> Read value RAM[3] and copy it onto the stack
pop pointer 0 -> Take the value from the stack and write into RAM[3]

## temp

## static
______________________________________________________________
#operations

## add

## sub

## neg

## eq

## gt

## lt

## and

## or

## not

## push segment i (Take memory from sement i put it on stack)

## pop segment i (Take stack element and put it in memory of segment i)
______________________________________________________________
