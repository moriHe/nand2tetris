# test sequence

## SimpleAdd
push constant 16
@16 
D=A
@SP
A=M
M=D    //M[A] = 16
@SP    // Stack goes up
M=M+1

add
@SP
M=M-1
A=M
D=M
@SP
M=M-1
A=M
D=D+M
@SP
A=M
M=D
@SP
M=M+1

## StackTest 
eq x==y
@SP
M=M-1           /// Dekr SP (get y)
A=M
D=M             // Lade y ins D Register
@SP
M=M-1           // Dekr SP (get x)
A=M
D=M-D           // Lade x - y ins D Register
@EQ_1
D;JEQ           // Wenn x - y = 0; Springe zu Ist Gleich
@SP             // Kein M=M-1 oder M=M+1 nötig. SP zeigt auf die nächste zu befüllende Stelle. Muss erst am Schluss inkrementiert werden um auf nächste zu befüllende Stelle + 1 zu zeigen
A=M
M=0             // x und y waren nicht gleich. Setze Memory bei SP auf 0 / False
@END_EQ_1       // Springe zum Ende
D;JMP
(EQ_1)          // Werte waren gleich
@SP             // Selbe wie im not equal Block dieser Funktion. Kein inkr/dekr nötig   
A=M
M=-1            // Setze Memory bei SP auf -1 / True
(END_EQ_1)
@SP             // Inkrementiere den Stack Pointer damit er eins vor dem letzten validen Wert (hier true/false) zeigt
M=M+1

lt x < y
gt x > y
sub x - y
neg -y
and x And y
or x Or y 
not Not x


## BasicTest

## PointerTest

##StaticTest
___________________________________________________
# segments

## Stack Pointer
@SP

## constant

## local
@LCL

## argument
@ARG

## this
@THIS

## that
@THAT

## pointer
push pointer 0 -> Read value RAM[3] and copy it onto the stack
pop pointer 0 -> Take the value from the stack and write into RAM[3]

## temp

## static
______________________________________________________________
#operations

## add

## sub

## neg

## eq

## gt

## lt

## and

## or

## not

## push segment i (Take memory from sement i put it on stack)

## pop segment i (Take stack element and put it in memory of segment i)
______________________________________________________________
